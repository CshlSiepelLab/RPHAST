%
% NOTE -- ONLY EDIT THE .Rnw FILE!!!  The .tex file is
% likely to be overwritten.
%
% \VignetteIndexEntry{rphast}
% \VignetteDepends{ape}
% \VignetteKeywords{Phylogenetics, conservation, Hidden Markov Models}
% \VignettePackage{rphast}

\documentclass[11pt]{article}
\usepackage{Sweave}


\begin{document}
\title{Detection of Accelerated Regions}
\author{M. J. Hubisz K. S. Pollard, and A. Siepel}
\SweaveOpts{echo=TRUE,fig=TRUE,eval=TRUE,include=TRUE,engine=R}
\maketitle

This example will go through the basic steps of detecting
accelerated evolution in a subtree.  In this case we will look
for accelerated regions in the mouse-rat subtree, and we will focus
on alignments from human chromosome 22.  The ideal way to go about this
would be to first identify conserved elements using the same procedure
as in example 1, but in a subset of the alignment which excludes the 
species of interest.  Then we can look in the full alignment at these
elements for signs of acceleration in mouse-rat.

Instead we will just use the conserved elements from the UCSC genome
browser.  They can be downloaded through the table browser for
the hg18 assembly, as well as the multiple alignment.


<<rarAnalysis1,fig=FALSE>>=
require("rphast")

exampleArchive <- system.file("extdata", "examples.zip", package="rphast")
unzip(exampleArchive, c("placentalMammals.mod", "chr22-elements.bed"))

# read the neutral model.  This file is also available
# through the UCSC genome browser
neutralMod <- read.tm("placentalMammals.mod") #read the neutral model

elements <- read.feat("chr22-elements.bed")
unique(elements$seqname)
elements$seqname <- "hg18" # need seqname in features to match seqname in
                           # alignment

@ 

Now, read the alignment.  The MAF file can be downloaded through the table browser
on the UCSC genome browser (under the hg18 assembly, Comparative Genomics Group, 
Conservation track, multiz44way table).  We have posted a version of this alignment
containing a subset of the 44 species on a server for the purposes of this example.

Since it is a large alignment we will use the pointer.only=TRUE option to read.msa.  This
option keeps the alignment object stored in C's memory, and only a pointer to object
is returned to R.  It can be much more efficient than passing the entire object between
R's memory and C's memory at every function call.  Objects stored as a pointer
can be used in much the same way as a normal R object, however, when they are sent to
a function, they are sent ``by reference''.  This means that, unlike ordinary R objects,
their value may be changed as a result of the function call.  Some RPHAST functions will
change the value of arguments which are sent as a pointer, but this behavior is always
documented in the help files.

<<rarAnalysis4,fig=FALSE>>=
seqnames <- c("hg18", "panTro2", "ponAbe2", "rheMac2", "mm9", "rn4", 
              "canFam2", "loxAfr2")
if (!file.exists("chr22.maf")) {
  if (!file.exists("chr22.maf.zip"))
    download.file("http://compgen.bscb.cornell.edu/rphast/chr22.maf.zip",
                  "chr22.maf.zip", method="auto")
  unzip("chr22.maf.zip", "chr22.maf")
}
align <- strip.gaps.msa(read.msa("chr22.maf", seqnames=seqnames, pointer.only=TRUE))
unlink("chr22.maf")

@ 

In this type of analysis it is usually necessary to apply some filters to the data
to control the rate of false positives.  In a real analysis we would suggest synteny
filters, as well as filters to remove regions with repeats or too much missing data.  
For this example we will implement a missing data filter.

The following code computes a set of features containing all positions with 
non-missing data at mouse and rat. Then it creates another set of features giving 
positions with data at a minimum of four species.  We use the coverage.feat function
to take the union of these features and the conserved elements to get ``informativeElements''.

<<fig=FALSE>>=

hasMouseRat <- informative.regions.msa(align, 2, c("mm9", "rn4"))
hasAtLeastFour <- informative.regions.msa(align, 4)
informativeElements <- coverage.feat(elements, hasMouseRat, hasAtLeastFour, 
                                     get.feats=TRUE)

@ 

We also want to regularize the lengths of the conserved elements,
so that we do not have to worry that the significance of the tests
are confounded by length.  So we split the filtered conserved elements
into fragments of size 50, and remove remaining fragments that
are too small:

<<rarAnalysis2,fig=FALSE>>=
splitLength <- 50
splitElements <- split.feat(informativeElements, max.length=splitLength)
splitElements <- splitElements[splitElements$end - splitElements$start + 1 == splitLength,]

@ 

Now we want to run phyloP on these split elements.  This calculates a likelihood
ratio for every feature (along with parameter estimates and p-values based on asymptotics):

<<<rarAnalyiss8,fig=FALSE>>=
obs.phyloP <- phyloP(neutralMod, msa=align, mode="ACC", features=splitElements,
                     subtree="mm9-rn4")

@ 

For these short elements with a fairly small species set, we do not
want to rely on asymptotics to calculate p-values.  Instead we will use 
non-parametric simulations to calculate p-values.  At the end of the vignette
we will also show a parametric alternative.

<<rarAnalysis6,fig=FALSE>>=

# first we get the set of sites to sample from: extract the informativeElements
# from the original alignment.  Note that extract.feature.msa will change 
# the alignment object if a pointer is passed in (as documented in the
# the help file), which is why we use the copy.msa function
elementAlign <- extract.feature.msa(copy.msa(align), informativeElements, 
                                    pointer.only=TRUE)

# we could simulate an MSA separately for each simulation, but it
# is more efficient to simulate one long MSA and then split it up later.
nrep <- 5000
simMsa <- sample.msa(elementAlign, nrep*splitLength, replace=TRUE)


# now we create a feature object which splits the simulated alignment into
# 5000 pieces of length 100
startIdx <- seq(from=1, by=splitLength, length.out=nrep)
features <- feat(seqname=names.msa(simMsa)[1], src="sim", feat=".",
                 start=startIdx, end=startIdx+splitLength-1)

# now run phyloP on this artifical alignment/features in the same way it
# was run on the real data
nonpara.phyloP <- phyloP(neutralMod, msa=simMsa, mode="ACC",
                         features=features, subtree="mm9-rn4")

@

We can make a Q-Q plot to compare the likelihood ratios between
real and simulated data:
<<<rarAnalyis9>>=

# THIS PLOT NEEDS SOME WORK!  HOW TO OVERLAY TWO PLOTS WITHOUT IT BEING REALLY CONFUSING?  
# OR SHOULD WE JUST DO THEM SIDE-BY-SIDE?
qqplot(obs.phyloP$lnlratio, nonpara.phyloP$lnlratio)
abline(0,1, lty=2)
lines(density(obs.phyloP$lnlratio), lty=1)
legend(x="bottomright", inset=0.1, 
       c("Q-Q plot with simulated likelihood ratios", 
         "density of observed likelihood ratios",
         "x=y"), pch=c(1, NA, NA), lty=c(NA, 1, 2))
h <- hist(obs.phyloP$lnlratio, breaks=100, plot=FALSE)
# rescale histogram to display relative frequencies on same plot
h$density <- h$density/max(h$density)*max(nonpara.phyloP$lnlratio)
plot(h, freq=FALSE, add=TRUE)
#axis(4)

@ 

Calculate p-values for the observed for each simulation set, and 
adjust the p-values for multiple testing using p.adjust.  Then
we can get a set of candidate ``RAR''s (Rodent Accelerated Regions):
<<<rarAnalysis10>>=

empirical.pval <- function(x, dist) {
  sum(x <= dist)/length(dist)
}

nonpara.pval <- sapply(obs.phyloP$lnlratio, empirical.pval, nonpara.phyloP$lnlratio)
hist(nonpara.pval, breaks=100)

nonpara.fdr <- p.adjust(nonpara.pval, method="BH")
sum(nonpara.fdr < 0.05)

# this gets the indices of elements with adjusted p-values < 0.05
nonpara.sigFeats <- splitElements[nonpara.fdr < 0.05,]
nrow(nonpara.sigFeats)
nonpara.sigFeats$feature <- "RAR"  # for rodent-accelerated region
coverage.feat(nonpara.sigFeats)
# can print out a features file that can be displayed on browser

write.feat("RAR.gff", nonpara.sigFeats)

@ 

Below we use phyloFit to estimate trees for the conserved elements and the RARs. Then
we use the ``ape'' package to plot the trees side-by-side, and we can see that there
does seem to be acceleration in the rodent lineage of the RARs.

<<>>=

consEleModel <- phyloFit(elementAlign, init.mod=neutralMod, no.freqs=TRUE, no.rates=TRUE)
rarAlign <- extract.feature.msa(copy.msa(align), nonpara.sigFeats)
rarModel <- phyloFit(rarAlign, init.mod=neutralMod, no.freqs=TRUE, no.rates=TRUE)

require("ape")
par(mfrow=c(1,2), mar=c(5,2,4,2))
maxX <- depth.tree(rarModel$tree, "mm9")
plot.phylo(read.tree(text=consEleModel$tree), x.lim=c(0, 0.5), 
           xaxt="s", main="Conserved Elements")
plot.phylo(read.tree(text=rarModel$tree), x.lim=c(0, 0.5), 
           xaxt="s", main="RAR")

@ 

In this example, phyloP was the most efficient function for calculating the likelihood, 
but phyloFit can be used to construct more general likelihood
ratio tests.  Here is how the test above could have been constructed
using phyloFit:

<<eval=FALSE,fig=FALSE>>=

accTest <- function(msa, mod, subtreeNode) {
  null.mod <- phyloFit(msa, init.mod=mod, scale.only=TRUE, 
                       no.freqs=TRUE, no.rates=TRUE, 
                       quiet=TRUE)
  alt.mod <- phyloFit(msa, init.mod=mod, scale.only=TRUE, scale.subtree=subtreeNode,
                      no.freqs=TRUE, no.rates=TRUE,
                      quiet=TRUE)
  tNullSub <- branchlen.tree(subtree(null.mod$tree, subtreeNode, super.tree=FALSE))
  tAltSub <- branchlen.tree(subtree(alt.mod$tree, subtreeNode, super.tree=FALSE))
  if (tNullSub >= tAltSub) return(0)
  alt.mod$likelihood - null.mod$likelihood
}

# this method is slower; let's just look at the first 50 elements as an example
sampleSize <- 50
obs.lr <- numeric(sampleSize)
for (i in 1:sampleSize) {
  obs.phyloP[i] <- accTest(sub.msa(align, start.col=splitElements[i,"start"],
                                      end.col=splitElements[i,"end"],
                                      refseq="hg18"),
                              neutralMod, "mm9-rn4")
}

nrep <- 100
sim.lr <- numeric(nrep)
for (i in 1:nrep) {
  simMsa <- sample.msa(elementAlign, splitLength, replace=TRUE)
  sim.lr[i] <- accTest(simMsa, neutralMod, "mm9-rn4")
}

@ 

We can also do a parametric test.  First we have to create a scaled 
neutral model, which represents a model for a conserved element without
any acceleration in rodents.  So we estimate a scale factor using 
the conserved elements, after removing the rodent branches.

<<<rarAnalysis5>>=

seqs <- names(align)
keepSeqs <- seqs[seqs != "mm9" & seqs != "rn4"]
prunedMod <- neutralMod
prunedMod$tree <- prune.tree(neutralMod$tree, keepSeqs, all.but=TRUE)
subAlign <- sub.msa(elementAlign, seqs=keepSeqs)
superTreeMod <- phyloFit(subAlign, init.mod=neutralMod, scale.only=TRUE,
                         no.freqs=TRUE, no.rates=TRUE)
superTreeScale <- branchlen.tree(superTreeMod$tree)/branchlen.tree(prunedMod$tree)
superTreeScale

scaledNeutralModel <- neutralMod
scaledNeutralModel$tree <- scale.tree(neutralMod$tree, scale=superTreeScale)

# also remove species from model which are not in alignment
scaledNeutralModel$tree <- prune.tree(scaledNeutralModel$tree, 
                                      seqs=seqs, all.but=TRUE)

# now we can do parametric simulations using our scaled
# nuetral model.  Again we will just simulate one big
# alignment, and split it up later, for efficiency.
simMsa <- simulate.msa(scaledNeutralModel, nrep*splitLength)

# now run phyloP on parametric simulation
para.phyloP <- phyloP(neutralMod, msa=simMsa, mode="ACC",
                      features=features, subtree="mm9-rn4")

para.pval <- sapply(obs.phyloP$lnlratio, empirical.pval, para.phyloP$lnlratio)
para.fdr <- p.adjust(para.pval, method="BH")
sum(para.fdr < 0.05)

# this gets the indices of elements with adjusted p-values < 0.05
para.sigIdx <- which(para.fdr < 0.05)
length(para.sigIdx)
para.sigFeats <- splitElements[para.sigIdx,]
para.sigFeats$feature <- "RAR"  # for rodent-accelerated region
coverage.feat(para.sigFeats)
plot.track(list(feat.track(para.sigFeats, "parametric RARs"),
                feat.track(nonpara.sigFeats, "non-parametric RAR"),
                feat.track(elements, "Conserved elements")), xlim=c(3e+07, 3.5e+07))

@ 

\end{document}
