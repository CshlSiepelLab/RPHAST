%
% NOTE -- ONLY EDIT THE .Rnw FILE!!!  The .tex file is
% likely to be overwritten.
%
% \VignetteIndexEntry{rphast}
% \VignetteKeywords{Phylogenetics, conservation, Hidden Markov Models}
% \VignettePackage{rphast}

\documentclass[11pt]{article}
\usepackage{Sweave}
\usepackage{url}
\usepackage{amsmath,epsfig,fullpage}

\begin{document}

\title{Conservation Analysis}
\author{M. J. Hubisz, K. S. Pollard, and A. Siepel}
\SweaveOpts{echo=TRUE,fig=TRUE,eval=TRUE,include=TRUE,engine=R,keep.source=TRUE}
\maketitle


Here we will show an example of conservation analysis in a non-model organism,
\emph{S. lycopersicon} (tomato).  An alignment of tomato, potato,
eggplant, pepper, and petunia is available through the table browser at 
Cornell's UCSC genome browser mirror (\url{http://genome-mirror.bscb.cornell.edu}).
The necessary files are also included in the rphast package's
example data set.

<<consAnalysis1,width=8,height=8>>=
require("rphast")

# extract the  alignment and annotation from the RPHAST package
exampleArchive <- system.file("extdata", "examples.zip", package="rphast")
unzip(exampleArchive, c("sol1.maf", "sol1.gp"))

# define tree using Newick string
tomatoTree <- "((((tomato, potato), eggplant), pepper), petunia);"

# read the alignment and switch to common names
align <- read.msa("sol1.maf")
names(align)
align$names <- c("tomato", "potato", "pepper", "petunia", "eggplant")
names(align)

# load the features
feats <- read.feat("sol1.gp")
unique(feats$seqname)

# they are all on chr2 so rename to "tomato" to cross-reference with alignment
feats$seqname <- "tomato"

# annotate UTRs and introns
feats <- addIntrons.feat(feats)
# in these features, UTRs are not annotated, so CDS is the same as exon.  So
# remove the exon features
feats <- feats[feats$feature != "exon",]

table(feats$feature)

# Now want to annotate non-coding regions.  First need to define
# chromosome boundaries

# make a feature that represents the entire chromosome
wholeChrom <- feat(seq="tomato", src=".", feature="all",
                  start=1, end=122080)

# annotate non-coding regions
coding.feats <- feats
noncoding.feats <- inverse.feat(feats, region.bounds=wholeChrom)
noncoding.feats$feature <- "noncoding"
feats <- rbind.feat(feats, noncoding.feats)

# now extract 4d sites from alignment using annotations
align4d <- get4d.msa(align, feats)

# estimate neutral model from 4d sites
neutralMod <- phyloFit(align4d, tree=tomatoTree, subst.mod="REV")

# now run phastCons to score/predict conserved elements
pc <- phastCons(align, neutralMod, expected.length=6, 
                target.coverage=0.125, viterbi=TRUE)

names(pc)

# the conserved elements are in a features object stored here:
cons.elements <- pc$most.conserved
# this shows how many bases are predicted to be conserved
coverage.feat(cons.elements)

# we get about 5% coverage of conserved elements
coverage.feat(cons.elements)/coverage.feat(wholeChrom)

# the posterior probabilities for every base are here:
names(pc$post.prob.wig)
dim(pc$post.prob.wig)

# and the overall likelihood is here:
pc$likelihood


# now run phyloP to get base-by-base scores
pp <- phyloP(neutralMod, align, method="LRT", mode="CONACC")

# examine these results- it is a data frame giving
# statistics for every base in the alignment
names(pp)
dim(pp)

geneTrack <- gene.track(feats, "genes")
consElTrack <- feat.track(cons.elements, "phastCons most conserved", col="red")
phastConsScoreTrack <- wig.track(coord=pc$post.prob.wig$coord,
                                 score=pc$post.prob.wig$post.prob,
                                 name="phastCons post prob", col="red", ylim=c(0, 1))
phyloPTrack <- wig.track(coord=pp$coord, score=pp$score, name="phyloP score", 
                         col="blue", smooth=TRUE, horiz.line=0)

plot.track(list(geneTrack, consElTrack, phastConsScoreTrack, phyloPTrack),
           xlim=c(60000, 68000))

@

<<hist>>=

# now examine conserved elements
ce <- pc$most.conserved
plot(density.feat(ce), type="l", ylim=c(0, 0.018), 
     main="Element Length by Type", xlab="Length")

# break conserved elements into coding/noncoding:

# this returns all conserved elements that overlap with coding.feats 
# by at least 50 percent
ce.coding <- overlap.feat(ce, coding.feats, min.percent=0.5)
# and this gets the ones which overlap by less than 50 percent:
ce.noncoding <- overlap.feat(ce, coding.feats, min.percent=0.5, 
                            overlapping=FALSE)
lines(density.feat(ce.coding), col="red")
lines(density.feat(ce.noncoding), col="blue")
legend(c("All", "Coding", "Noncoding"), x="topright", inset=0.01, 
       lty=1, col=c("black", "red", "blue"))
@ 
<<width=8,height=4>>=
# so coding elements tend to be longer

par(mfrow=c(1,3))
# look at fold-enrichment of each annotation type by conserved element
enrich <- enrichment.feat(ce, feats, wholeChrom)
barplot(enrich$enrichment, names.arg=enrich$type, 
        col=rainbow(nrow(enrich)),
        main="Enrichment of\nConserved Elements", cex.main=1.5,
        ylab="Fold Enrichment", cex.lab=1.5)
# look at the composition of the conserved elements
comp <- composition.feat(ce, feats)
pie(comp$composition, labels=comp$type, col=rainbow(nrow(comp)), radius=1.0,
    main="Composition of\nConserved Elements", cex.main=1.5, cex.lab=1.5)
# compare with background composition
comp <- composition.feat(wholeChrom, feats)
pie(comp$composition, labels=comp$type, col=rainbow(nrow(comp)), radius=1.0,
    main="Background\nComposition", cex.main=1.5, cex.lab=1.5)

@ 
<<>>=

# Run phastCons again, this time try to estimate the transition rates
# between conserved and non-conserved
pcEM <- phastCons(align, neutralMod, viterbi=TRUE, estimate.transitions=TRUE) 
names(pcEM)
# note this has the same elements as pc, plus an estimate for rho
pcEM$transition.rates

# and the likelihood is higher since we estimate the rates by
# maximum likelihood
pcEM$likelihood

# now coverage is a bit higher, at 23%
# (note rho only defines a prior expectation for coverage)
coverage.feat(pcEM$most.conserved)/coverage.feat(wholeChrom)

# compare the results with and without --estimate-rho
coverage.feat(pcEM$most.conserved, pc$most.conserved)
coverage.feat(pcEM$most.conserved, pc$most.conserved, or=TRUE)
coverage.feat(pcEM$most.conserved, pc$most.conserved, 
             not=c(FALSE, TRUE), region.bounds=wholeChrom)
coverage.feat(pcEM$most.conserved, pc$most.conserved, 
             not=c(TRUE, FALSE), region.bounds=wholeChrom)
          
@ 
<<width=8,height=4>>=
plot.track(list(feat.track(pc$most.conserved, name="No estimation"),
                feat.track(pcEM$most.conserved, name="With estimation")))

@ 
<<>>=
plot(density.feat(pc$most.conserved), type="l", 
     main="Distribution of Element Lengths", xlab="Length", xlim=c(0, 1000))
lines(density.feat(pcEM$most.conserved), col="red")
legend(x="topright", inset=0.01, c("without estimation", "with estimation"), 
       lty=1, col=c("black", "red"))
@ 

\end{document}
